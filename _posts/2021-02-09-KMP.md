---
toc : true
title : "[Algorithm] KMP 문자열 검색 알고리즘"
category : 
    - TIL
    - Algorithm
---
### KMP 알고리즘 이란?
KMP 알고리즘은 알고리즘을 고안한 세명의 이름 $($Knuth, Morris, Prett)의 앞 글자를 따와 KMP 알고리즘이라 불리게 되었습니다.

KMP 알고리즘은 텍스트에서 부분 문자열을 검색하는데 있어 유용한 알고리즘 입니다.
예를 들어 "ABCABABCDE" 문자열에서 부분 문자열 "ABC"가 총 몇번 등장하는지 알아봅시다. 단순하게 부분 문자열 "ABC"의 개수를 새는 방법은 다음과 같이 "ABC" 부분 문자열을 한칸씩 옮겨 가며 같은지 비교하는 방법입니다.

![check_substr-1](/assets/images/algo/check_substr-1.png)

![check_substr-2](/assets/images/algo/check_substr-2.png)

![check_substr-3](/assets/images/algo/check_substr-3.png)

![check_substr-4](/assets/images/algo/check_substr-4.png)

![check_substr-5](/assets/images/algo/check_substr-5.png)

![check_substr-6](/assets/images/algo/check_substr-6.png)

![check_substr-7](/assets/images/algo/check_substr-7.png)

![check_substr-8](/assets/images/algo/check_substr-8.png)

위의 과정을 통해서 주어진 문자열 "ABCABABCDE" 안에 부분 문자열 "ABC"가 총 두번 등장 하는 것을 알 수 있습니다. 해당 과정의 시간 복잡도는 문자열의 길이를 N, 부분 문자열의 길이를 M이라 할때 각 문자열의 인덱스에 대해 부분 문자열이 일치하는지 일일이 비교하므로 O$($NM)이 걸리게 됩니다. 

하지만 KMP 알고리즘을 이용한다면 시간 복잡도를 O$($N+M)까지 단축시키는게 가능합니다.

### KMP 알고리즘 이해를 위한 사전 개념
KMP 알고리즘을 이해하고 활용하기 위해서는 두가지 개념을 이해할 필요가 있습니다.

1. **<i>접두사$($prefix), 접미사$($suffix)</i>**

"apple"의 접두사와 접미사를 예를 들면 접두사와 접미사에 대해 이해될 것 입니다.

**<apple의 접두사>**
a
<br>
ap
<br>
app
<br>
appl
<br>
apple

**<apple의 접미사>**
e
<br>
le
<br>
ple
<br>
pple
<br>
apple

2. **<i>pi 배열</i>**

`pi[i]`는 주어진 문자열의 0~i 까지의 부분 문자열 중에서 `접두사와 접미사가 일치하는 최대 길이 입니다.`
(이때 prefix가 0~i  까지의 부분 문자열과 같으면 안된다.)

이해를 돕기위해 예시를 들어 보겠습니다.

![pi배열](/assets/images/algo/piarray.png)

### KMP 알고리즘 원리 및 활용

KMP 알고리즘의 원리는 앞에서 배운 접두사와 접미사의 공통된 부분을 활용하여 불필요한 중간 과정을 점프하는 것 입니다.

![kmp](/assets/images/algo/kmp-2.png)



![kmp](/assets/images/algo/kmp-1.png)

![kmp](/assets/images/algo/kmp-3.png)

### 접두사와 접미사가 일치하는 최대 길이 $($p[i]) 구하기
그렇다면 문자열의 접두사와 접미사의 최대 길이인 p[i]값은 어떻게 구할 수 있을까요?
문자열의 인덱스를 나타내는 변수 i와 j를 사용하여 아래와 같은 순서의 과정을 통해서 `최대 일치 길이`값을 구하는 함수를 구현할 수 있습니다.

1. 모든 문자를 하나씩 검사를 하면서 j가 0보다 크고 인덱스 i번째 문자와 j번째 문자가 **같지 않으면** j에서 1을 뺀 인덱스 값으로 돌아간다 $($i만 증가, j는 1 감소).

2. i번째 인덱스의 값과 j번째 인덱스의 값이 **일치하는 경우** i번째 인덱스의 값은 j위치 $($index)에 1을 더한값이 되며 j의 위치를 1증가 시켜준다 $($i, j 둘다 증가).

부분 문자열 "ABAABAB"을 예로 들어서 최대 일치길이를 구하는 과정을 알아보겠습니다.








