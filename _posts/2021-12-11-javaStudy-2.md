---
toc: true
title: "[Java 기초] 자바 데이터 타입, 변수 그리고 배열"
category:
  - Java
---

이번 포스트에서는 자바에서의 변수 타입과 배열에 대해서 알아보도록 하겠다.

## 목차

- 프리미티브 타입과 레퍼런스 타입
- 상수
- 리터럴
- 타입 추론 var
- 타입 프로모션
- 변수의 스코프와 라이프타임
- 문자열 비교 메소드
- 1차 및 2차 배열 선언하기

<small>해당 목차는 백기선님의 자바 스터디 2주차 과제에서 가져왔습니다.</small>

---

## 변수의 타입

### 프리미티브 타입
기본형인 프리미티브 타입은 논리형, 문자형, 정수형, 실수형 같은 실제 값을 저장하는데 사용된다.

### 레퍼런스 타입
참조형 타입은 어떤 값이 저장되어있는 주소값을 값으로 갖는다.

변수의 타입으로 클래스의 이름이 사용되며 클래스 이름이 참조변수의 타입이 된다.

때문에 새로운 클래스를 작성하는 것은 새로운 참조형을 추가하는 것과 같다.

#### 초기화 방법

```java
Animal dog = new Animal(); // Animal 객체를 생성해서, 그 주소를 dog에 저장
```

객체 생성 연산자 new의 결과는 생성된 객체의 주소이다.

이 주소가 참조변수 dog에 저장되는 것이다.

### 상수
한번 값을 입력받으면 값을 변경할 수 없는 변수.

변수 타입 앞에 **final**을 붙여서 상수를 선언해 준다.

```java
final int MAX_PRICE = 1000; // 상수이름은 관례상 대문자
```

### 리터럴
그 자체로 값을 의미하는 것을 말한다.

ex) 1000



## 타입 추론 var
`var` 타입으로 변수를 선언하고 초기화 하면 컴파일러는 초기화된 값으로 타입을 추론한다.

```java
var list = new ArrayList<String>();

if(list instanceof ArrayList) {
    System.out.println("This is a ArrayList");
}
```

**실행결과**
This is a ArrayList

### 제약조건
1. 지역 변수에서만 사용가능. $($클래스의 멤버 변수 선언시 사용 불가)

2. null로 초기화 불가

3. 배열의 타입으로 사용 불가

4. Lambda에 사용 불가

---

## 타입 프로모션
타입 프로모션은 자동 형변환과 같은 말이다.

피연산자와 피연산자 끼리의 연산 결과는 두 피연산자중 더 큰 범위의 자료형이 된다. $($데이터의 손실을 막기위해)

``` java
int a = 1_000_000;
int b = 2_000_000;

long c = a * b;
System.out.println(c); // -132412412
// ???
```

int형인 a와 b가 곱해진 결과 2000000000000은 int형 변수의 결과값으로 저장되었다가 long 자료형의 c에 저장된다. 때문에 결과값이 int형의 범위를 넘어가게 되므로 쓰래기 값이 출력된다.

다음과 같이 작성하여야 한다.

``` java
long c = (long)a * b;
```


JVM의 피연산자 스택은 피연산자를 4바이트 단위로 저장하기 때문에 4바이트보다 작은 자료형의 계산할 때는 4바이트로 변환한 뒤에 연산을 수행한다. 

때문에 메모리를 효율적으로 관리하기 위한 목적이 아니라면 short, byte과 같은 자료형의 사용보다 **int형의 사용이 연산속도에서는 더 효율적이다.**

`다른 자료형 + 문자열`의 결과는 항상 문자열로 변환되어 나온다.

7 + "" -> "7" + "" -> "7"

## 변수의 스코프와 라이프타임
변수는 변수가 선언된 위치에 따라서 **클래스변수, 인스턴스변수, 지역변수**가 있다.

```java
class Variables {
    int iv; // 인스턴스변수
    static int cv; // 클래스변수(static변수, 공유변수)

    //메서드 영역
    void method() {
        int lv = 0; // 지역변수
    }
}
```

### 인스턴스변수
- 인스턴스가 생성될 때 힙 영역에 생성됨.
- 독립적인 저장공간을 가짐.
- 참조변수가 인스턴스를 가리키지 않을때 가비지컬렉터에 의해 삭제됨.
- 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언.

### 클래스변수
- static 키워드를 인스턴스변수 앞에 붙여서 선언.
- 클래스가 메모리에 올라갈 때 생성됨.
- 인스턴스 생성없이도 접근가능
- 모든 인스턴스가 저장공간을 공유
- 모든 인스턴스들이 공통적인 값을 유지해야하는 경우에 클래스변수로 선언.

클래스변수 사용시 **클래스이름.클래스변수** 형태로 한다.

참조변수.클래스변수도 가능하지만 클래스변수를 인스턴스변수로 오해할 여지가 있다.

### 지역변수
- 메서드 내에서만 사용가능
- 메서드 종료되면 소멸
- 매개변수 또한 지역변수이다.

### 예제
카드게임에 사용되는 카드의 속성을 분석해보겠다.

카드의 `폭`과 `높이`는 모든 카드가 동일하기 때문에

**클래스변수 = 폭, 높이**

카드의 `무늬`와 `숫자`는 각 카드마다 고유하기 때문에

**인스턴스변수 = 무늬, 숫자**

```java
class Card {
    String kind;
    int number;

    static int width = 150;
    static int height = 250;
}

class CardGame {
    public static void main(String[] args) {
        // 객체생성없이도 클래스이름.클래스변수로 사용가능
        System.out.println("카드의 폭 : " + Card.width);
        System.out.println("카드의 높이 : " + Card.height);
        
        Card c1 = new Card();
        Card c2 = new Card();
        
        c1.kind = "King";
        c1.number = 7;
        
        c2.kind = "Queen";
        c2.number = 2;

        System.out.println("c1은 " + c1.kind + ", " + c1.number "이며, 크기는 " + c1.width + ", " + c2.height);
    }
}
```

**출력결과**
```
카드의 폭 : 150
카드의 높이 : 250
c1은 King, 7이며, 크기는 150, 250
```
---

## 문자열 비교
문자열이 일치하는지를 확인하는 연산에는 `==`이 아닌 `equals()` 메서드를 사용한다.

`==`의 경우 두 문자열의 내용이 일치해도 서로 다른 객체라면 false를 반환한다.

### equals()
두 문자열이 같으면 true, 다르면 false 반환

### equalsIgnoreCase()
문자열의 대소문자 구별하지 않고 비교

---

## 배열

### 1차원 배열 선언

```java
// 타입[] 변수이름;
// 변수이름 = new 타입[길이];

int[] score; // 참조변수 score 선언. 참조변수를 위한 공간만 만들어짐
score = new int[5]; // new 연산자에 의해 int타입의 실제 저장공간 생성
```

참조변수 score에 배열의 주소가 저장됨.

### 배열의 복사 System.arraycopy()
배열의 요소에 하나씩 접근해서 복사하는 for문과 달리 System.arraycopy()는 지정된 범위의 값들을 한번에 복사한다.

num[0]에서 newNum[0]로 num.length개의 데이터를 복사하는 코드 

```java
System.arraycopy(num, 0, newNum, 0, num.length);
```

### 2차원 배열 선언

```java
// 타입[][] 변수이름;

//4행 3열의 2차원 배열 생성
int[][] score = new int[4][3];
```

**2차원 배열 초기화**

```java
int[][] score = {
    {100, 100, 100},
    {20, 20, 20},
    {30, 30, 30},
    {40, 40, 40},
    {50, 50, 50}
};
```

![2차원배열](/assets/images/Back_End/array2.png)

2차원 배열을 초기화 하게 되면 메모리상에 다음과 같은 형태로 저장이된다.

배열의 배열 형태로 저장이된다.

score.length의 결과 => 5

score[0].length의 결과 => 3

## 가변 배열

다음과 같이 자유로운 형태의 배열 구성 또한 가능하다.

```java
int[][] score = {
    {100, 100, 100},
    {20, 20},
    {30, 30},
    {40}
};
```

![가변배열](/assets/images/Back_End/vary2array.png)

---

> 참조 <br>
> Java의 정석 $($남궁 성) <br>
> [whiteship 자바 라이브 스터디](https://github.com/whiteship/live-study)